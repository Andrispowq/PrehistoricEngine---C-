# PREHISTORIC ENGINE WORLD FILE #

# Usage: # means comment, but make sure to add a space after the hash
# First you have to specify the model and texture loading directory, where your models and texture are located. The locations of the textures and models are relative
# to this location, eg.: if texture directory is res/textures/, and you load a texture from pbr/tex_DIF.png, it will load it from res/textures/pbr/tex_DIF.png
# Make sure not to have double slashes, have it only after the directory or before every texture!
# After model and texture loading, you can create a material:
#	- materials.add <matname>						creates a new material
#	- material.<matname>.<type> <name> <value>		adds a new component to <matname> texture of <type>, with name <name> and value <value>, eg.:
#		material.sphere.vec3 colour 1,0.3,0.2 adds a vec3 component to material 'sphere' with the value (1, 0.3, 0.2), and name 'colour'
# After this stage, you can create the GameObjects, the building blocks of the scene. Everything is a GameObject, a GUI element, a particle system, and a character
# Creation:
#	- world.object <name> <position> <rotation> <scale>
#	This line will create a new object called 'name', at position 'position', with a rotation 'rotation', and scale 'scale'. You don't have to give it a position, rotation
#	or scale, but you cannot add just a rotation, just a rotation and scale, or just a scale. Note that the rotation is given as Euclidian rotation, so 1 rotation value per axis
#	and it is given in degrees, not radians, eg.: (60, -30, 70) will rotate the model 60 degrees on the X axis, -30 degrees on the Y axis, and 70 degrees on the Z axis.
#	The engine supports GameObject hierarchy trees, which means that you can have GameObject inheritance. Example:
#	- world.object.game.particleSystem particle 0,0,0
#	This line creates a GameObject called 'particle', which is a child object of 'particleSystem', which is a child of 'game'. Note that the position (0, 0, 0) is relative to it's parent's position
#	and if the parent has a parent which in this example has, and it's called 'game' it's position is also relative to it's parent's position. This requires that 'game'
#	is declared first, then 'particleSystem', but indicating that it's a child of 'game', and then 'particle' can be created.
# After that, you can add various components to the GameObjects in order to add functionality to them. The usage:
#	- object.<name>.component <compName> <values...>
#	This line will add a component of type <compName> with the name <compName> to GameObject called <name>. Note, that if this object is part of an inheritance tree,
#	you have to write out the whole inheritance tree, from the top. The <values...> is the parameters of the component we wish to add, like in the case of Renderer,
#	<values...> will be the model we want to renderer, the material applied to the model and a shader, which does not need to be created in this file, it's generated by the engine

# CONFIGURATION
world.name newWorld

# DIRECTORIES
directories.models res/models/
directories.textures res/textures/

# MODELS/TEXTURE TO LOAD clockwise
models.load quadModel quad.obj clockwise
models.load sphereModel sphere.obj counter-clockwise
models.load atmosphere sphere.obj double-sided
models.load cubeModel cube.obj counter-clockwise

# This means that the models are loaded asynchronously, on separate threads, and this command launches the execution
models.dispatch

textures.load oak_DIF oakFloor/oakFloor_DIF.png
textures.load oak_NRM oakFloor/oakFloor_NRM.png
textures.load oak_MROT oakFloor/oakFloor_MROT.png

textures.load metal_DIF metalFloor/metalFloor_DIF.png
textures.load metal_NRM metalFloor/metalFloor_NRM.png
textures.load metal_MROT metalFloor/metalFloor_MROT.png

# This means that the textures are loaded asynchronously, on separate threads, and this command launches the execution
textures.dispatch

# CREATING MATERIALS FROM TEXTURES AND OTHER DATA
# add will create a new Material
# Material components: texture, vec4, vec3, vec2, float, int
materials.add mat_quad
materials.mat_quad.texture albedo oak_DIF
materials.mat_quad.texture normal oak_NRM
materials.mat_quad.texture mrot oak_MROT
materials.mat_quad.vec4 mrot -1,-1,-1,0
materials.mat_quad.float emission 0

materials.add mat_metal
materials.mat_metal.texture albedo metal_DIF
materials.mat_metal.texture normal metal_NRM
materials.mat_metal.texture mrot metal_MROT
materials.mat_metal.vec4 mrot -1,-1,-1,0
materials.mat_metal.float emission 0

materials.add mat_sphere
materials.mat_sphere.vec3 colour 1,1,1
materials.mat_sphere.texture normal metal_NRM
materials.mat_sphere.vec4 mrot 1,0.1,1,-1
materials.mat_sphere.float emission 0

materials.add mat_iron
materials.mat_iron.vec3 colour 0.56,0.57,0.58
materials.mat_iron.vec4 mrot 1,0.3,1,-1
materials.mat_iron.float emission 0

materials.add mat_light0
materials.mat_light0.vec3 colour 0.1,1,0.1
materials.mat_light0.vec4 mrot 0.4,0.3,1,-1
materials.mat_light0.float emission 5

materials.add mat_light1
materials.mat_light1.vec3 colour 1,0.1,0.1
materials.mat_light1.vec4 mrot 0.4,0.3,1,-1
materials.mat_light1.float emission 20

materials.add mat_sphere1
materials.mat_sphere1.vec3 colour 0.78,0.56,0.45
materials.mat_sphere1.vec4 mrot 1,0.5,1,-1

materials.add mat_sphere2
materials.mat_sphere2.vec3 colour 0.78,0.56,0.45
materials.mat_sphere2.vec4 mrot 0,0.3,1,-1

# GAMEOBJECT CREATION
# You can specify position, rotation, and scale, but only in this order, and you cannot have rotation or scale specified without position and scale without position and rotatino
root.object cube0 0,1,0 -90,0,0 1,1,1 //position, rotation, scaling
root.object cube1 0,-1,0 90,0,0 1,1,1 //position, rotation, scaling
root.object cube2 1,0,0 0,90,0 1,1,1 //position, rotation, scaling
root.object cube3 -1,0,0 0,-90,0 1,1,1 //position, rotation, scaling
root.object cube4 0,0,1 0,0,0 1,1,1 //position, rotation, scaling
root.object cube5 0,0,-1 0,180,0 1,1,1 //position, rotation, scaling
root.object otherQuad -10,0,0 -90,0,0 1,1,1 //position, rotation, scaling
root.object metalPlane 0,-25,0 0,0,0 40,0.5,40 //position, rotation, scaling
root.object sphere -5,1,-3 0,0,0 1,1,1 //position, rotation, scaling
root.object light0 2,3,5 0,0,0 0.5,0.5,0.5
root.object sabre_metal_part 4,-2,-3 0,0,0 0.03,0.5,0.03
root.object sabre 4,0.25,-3 0,0,0 0.03,1.75,0.03
root.object sphere1 -30,20,20
root.object sphere2 20,10,-30

# COMPONENT ADDITION
# Supported component tpyes: Renderer, Light
# Renderer: model name, shader type (basic, or pbr), and material name required
# Light: light colour (3 components, [0;1]), and an intensity required
object.cube0.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube1.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube2.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube3.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube4.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube5.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.otherQuad.component Renderer quadModel,pbr,mat_metal //model name, shader type(currently: basic, pbr), material name
object.metalPlane.component Renderer cubeModel,pbr,mat_iron //model name, shader type(currently: basic, pbr), material name
object.sphere.component Renderer sphereModel,pbr,mat_sphere //model name, shader type(currently: basic, pbr), material name

object.light0.component Light 0,1,0;1000;150
object.light0.component Renderer sphereModel,pbr,mat_light0

object.sabre.component Light 1,0,0;500;100
object.sabre.component Renderer cubeModel,pbr,mat_light1
object.sabre_metal_part.component Renderer cubeModel,pbr,mat_iron

object.sphere1.component Renderer sphereModel,pbr,mat_sphere1
object.sphere2.component Renderer sphereModel,pbr,mat_sphere2