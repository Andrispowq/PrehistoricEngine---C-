# PREHISTORIC ENGINE WORLD FILE #

# Usage: # means comment, but make sure to add a space after the hash
# First you have to specify the model and texture loading directory, where your models and texture are located. The locations of the textures and models are relative
# to this location, eg.: if texture directory is res/textures/, and you load a texture from pbr/tex_DIF.png, it will load it from res/textures/pbr/tex_DIF.png
# Make sure not to have double slashes, have it only after the directory or before every texture!
# After model and texture loading, you can create a material:
#	- materials.add <matname>						creates a new material
#	- material.<matname>.<type> <name> <value>		adds a new component to <matname> texture of <type>, with name <name> and value <value>, eg.:
#		material.sphere.vec3 colour 1,0.3,0.2 adds a vec3 component to material 'sphere' with the value (1, 0.3, 0.2), and name 'colour'
# After this stage, you can create the GameObjects, the building blocks of the scene. Everything is a GameObject, a GUI element, a particle system, and a character
# Creation:
#	- world.object <name> <position> <rotation> <scale>
#	This line will create a new object called 'name', at position 'position', with a rotation 'rotation', and scale 'scale'. You don't have to give it a position, rotation
#	or scale, but you cannot add just a rotation, just a rotation and scale, or just a scale. Note that the rotation is given as Euclidian rotation, so 1 rotation value per axis
#	and it is given in degrees, not radians, eg.: (60, -30, 70) will rotate the model 60 degrees on the X axis, -30 degrees on the Y axis, and 70 degrees on the Z axis.
#	The engine supports GameObject hierarchy trees, which means that you can have GameObject inheritance. Example:
#	- world.object.game.particleSystem particle 0,0,0
#	This line creates a GameObject called 'particle', which is a child object of 'particleSystem', which is a child of 'game'. Note that the position (0, 0, 0) is relative to it's parent's position
#	and if the parent has a parent which in this example has, and it's called 'game' it's position is also relative to it's parent's position. This requires that 'game'
#	is declared first, then 'particleSystem', but indicating that it's a child of 'game', and then 'particle' can be created.
# After that, you can add various components to the GameObjects in order to add functionality to them. The usage:
#	- object.<name>.component <compName> <values...>
#	This line will add a component of type <compName> with the name <compName> to GameObject called <name>. Note, that if this object is part of an inheritance tree,
#	you have to write out the whole inheritance tree, from the top. The <values...> is the parameters of the component we wish to add, like in the case of Renderer,
#	<values...> will be the model we want to renderer, the material applied to the model and a shader, which does not need to be created in this file, it's generated by the engine

# DIRECTORIES
directories.models res/models/
directories.textures res/textures/

# MODELS/TEXTURE TO LOAD clockwise
models.load quadModel quad.obj counter-clockwise
models.load sphereModel sphere.obj clockwise
models.load cubeModel cube.obj clockwise

textures.load oak_DIF oakFloor/oakFloor_DIF.png
textures.load oak_NRM oakFloor/oakFloor_NRM.png
textures.load oak_MROT oakFloor/oakFloor_MROT.png

textures.load metal_DIF metalFloor/metalFloor_DIF.png
textures.load metal_NRM metalFloor/metalFloor_NRM.png
textures.load metal_MROT metalFloor/metalFloor_MROT.png

# This means that the textures are loaded asynchronously, on separate threads, and this command launches the execution
textures.dispatch

# CREATING MATERIALS FROM TEXTURES AND OTHER DATA
# add will create a new Material
# Material components: texture, vec4, vec3, vec2, float, int
materials.add mat_quad
materials.mat_quad.texture albedo oak_DIF
materials.mat_quad.texture normal oak_NRM
materials.mat_quad.texture mrot oak_MROT
materials.mat_quad.vec4 mrot -1,-1,-1,0
materials.mat_quad.vec3 emission 0,0,0

materials.add mat_metal
materials.mat_metal.texture albedo metal_DIF
materials.mat_metal.texture normal metal_NRM
materials.mat_metal.texture mrot metal_MROT
materials.mat_metal.vec4 mrot -1,-1,-1,0
materials.mat_metal.vec3 emission 0,0,0

materials.add mat_sphere
materials.mat_sphere.vec3 colour 1,1,1
materials.mat_sphere.texture normal metal_NRM
materials.mat_sphere.vec4 mrot 1,0.1,1,-1
materials.mat_sphere.vec3 emission 0,0,0

materials.add mat_iron
materials.mat_iron.vec3 colour 0.56,0.57,0.58
materials.mat_iron.vec4 mrot 1,0.3,1,-1
materials.mat_iron.vec3 emission 0,0,0

materials.add mat_light0
materials.mat_light0.vec3 colour 0.78,0.56,0.45
materials.mat_light0.vec4 mrot 0.4,0.3,1,-1
materials.mat_light0.vec3 emission 10,10,10

materials.add mat_light1
materials.mat_light1.vec3 colour 0.78,0.56,0.45
materials.mat_light1.vec4 mrot 1,0.5,1,-1
# materials.mat_light1.vec3 emission 0,0,0.2

materials.add mat_light2
materials.mat_light2.vec3 colour 0.78,0.56,0.45
materials.mat_light2.vec4 mrot 0,0.3,1,-1
# materials.mat_light2.vec3 emission 0.2,0,0

# GAMEOBJECT CREATION
# You can specify position, rotation, and scale, but only in this order, and you cannot have rotation or scale specified without position and scale without position and rotatino
world.object cube0 0,1,0 -90,0,0 1,1,1 //position, rotation, scaling
world.object cube1 0,-1,0 90,0,0 1,1,1 //position, rotation, scaling
world.object cube2 1,0,0 0,90,0 1,1,1 //position, rotation, scaling
world.object cube3 -1,0,0 0,-90,0 1,1,1 //position, rotation, scaling
world.object cube4 0,0,1 0,0,0 1,1,1 //position, rotation, scaling
world.object cube5 0,0,-1 0,180,0 1,1,1 //position, rotation, scaling
world.object otherQuad -10,0,0 -90,0,0 1,1,1 //position, rotation, scaling
world.object metalPlane 0,-25,0 0,0,0 40,0.5,40 //position, rotation, scaling
world.object sphere -5,1,-3 0,0,0 1,1,1 //position, rotation, scaling
world.object light0 20,30,20
world.object light1 -30,20,20
world.object light2 20,10,-30

# COMPONENT ADDITION
# Supported component tpyes: Renderer, Light
# Renderer: model name, shader type (basic, or pbr), and material name required
# Light: light colour (3 components, [0;1]), and an intensity required
object.cube0.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube1.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube2.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube3.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube4.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.cube5.component Renderer quadModel,pbr,mat_quad //model name, shader type(currently: basic, pbr), material name
object.otherQuad.component Renderer quadModel,pbr,mat_metal //model name, shader type(currently: basic, pbr), material name
object.metalPlane.component Renderer cubeModel,pbr,mat_iron //model name, shader type(currently: basic, pbr), material name
object.sphere.component Renderer sphereModel,pbr,mat_sphere //model name, shader type(currently: basic, pbr), material name

object.light0.component Light 1,1,1;10000
object.light0.component Renderer sphereModel,pbr,mat_light0

# object.light1.component Light 0,0,1;30000
object.light1.component Renderer sphereModel,pbr,mat_light1

# object.light2.component Light 1,0,0;40000
object.light2.component Renderer sphereModel,pbr,mat_light2